# DevLog

## POC

This build version demonstrates the core functions that exist in Super Oiram.

### General Structure

Oiram (The player sprite) contains three separate states. These states are class based Finite State machines that
determine how/where to move the player sprite. A player controller class that uses Unity's new Input System is used
to switch states given the inputs and current state of the player. A utility class exists which is used to provide 
logic functions that don't necessarily belong to any kind of sprite character (Rect collision checking, camera bounds, etc).

A Level class exists that is responsible for dynamically loading in levels using a bitmap level editor. Giving a Level object a reference
to an array of textures loads a level at the start based on the pixels of the texture. The utility function uses the bounds of the level texture to
determine where to stop the camera and make sure the player can't go off the side of the screen.


### Structure and Potential problems of the Finite State Machine

While the Finite State machine allows for a higher level of Seperation of Concern it heavily violates the open closed principle.
Every time I add a new state I have to consider how/when that state can be swapped to and if I can ever coexist with a current state.
This is partly why the player character uses three separate states.

1) **Ground State**

These types of states are simply used to change the y direction in which the player moves. It does NOT actually move the player.

2) **Move State**

These states are responsible for much more. These states change the x direction, check for collisions, and they are the ones moving the player.

3) **Game Stat**

These states are simply used to see if the player has won/lost or is currently playing. They flag an event system whenever the player wins or loses
and also disable the player controller when necessary.

Looking back I structured my state system poorly. State is an abstract class which is meant to be inherited by any state and the player character contains three States.
What I should have done is further subclass State with another level of abstract classes (GroundState : State, MoveState : State, etc). I've already made several logic errors
where I accidently assign a MoveState into the groundState which causes for some hard debugging. With the player's state machine complete I may consider revisiting this and
fixing the debt I've created.

